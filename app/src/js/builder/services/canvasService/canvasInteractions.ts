import { snapToGrid } from '../../utils/grid.js';
import { exitTransition, highlightElement, enterTransition } from '../../utils/transitions.js';
import { createNodeInstance, checkPositionValidity } from '../nodeService/nodeService.js';
import { initDraggableNodes, setupCanvasDropArea } from '../dragDropService/dragDropService.js';
import { cancelConnectionDrawing } from '../connectionService/connectionService.js';
import { initZoomControls } from '../../utils/zoom.js';
import { showNotification } from '../../utils/notifications.js';
import { getNodes, addNode } from '../nodeService/nodeState.js';

export function initCanvasInteractions(): void {
  const canvas = document.getElementById('canvas') as HTMLElement;
  const canvasContent = canvas?.querySelector('.canvas-content') as HTMLElement;

  if (!canvas || !canvasContent) return;

  canvas.addEventListener('click', e => {
    const target = e.target as HTMLElement;
    if (target.id === 'canvas' || target.classList.contains('canvas-content')) {
      document.querySelectorAll('.node-selected').forEach(node => {
        node.classList.remove('node-selected');
        exitTransition(node as HTMLElement, 'scale', 150, 0, false);
      });
      cancelConnectionDrawing();
    }
  });

  initZoomControls(canvas);
  setupCanvasDropArea(canvas);

  canvas.addEventListener('drop', async e => {
    e.preventDefault();
    canvas.style.backgroundColor = '#1e1e1e';

    const dataTransfer = e.dataTransfer;
    if (!dataTransfer) return;

    let nodeType = dataTransfer.getData('text/plain');
    let flowType = 'flow';

    try {
      const nodeData = JSON.parse(dataTransfer.getData('application/json') || nodeType);
      nodeType = nodeData.type;
      flowType = nodeData.flowType || 'flow';
    } catch (err) {
      console.log('Using direct type:', nodeType);
    }

    // Validate nodeType is clean and not HTML content
    if (!nodeType || nodeType.includes('<') || nodeType.includes('>') || nodeType.length > 50) {
      console.error('Invalid node type detected:', nodeType);
      showNotification('Invalid component type. Please try dragging again.', 'error');
      return;
    }

    const canvasRect = canvas.getBoundingClientRect();
    const currentZoom = parseFloat(canvas.dataset.zoomLevel || '1');
    const x = (e.clientX - canvasRect.left + canvas.scrollLeft) / currentZoom;
    const y = (e.clientY - canvasRect.top + canvas.scrollTop) / currentZoom;
    const snappedX = snapToGrid(x - 90);
    const snappedY = snapToGrid(y - 50);

    console.log(`Drop position: x=${x}, y=${y}, snapped: x=${snappedX}, y=${snappedY}`);
    console.log(`Creating node of type: "${nodeType}" with flowType: "${flowType}"`);

    if (!checkPositionValidity(snappedX, snappedY, 220, 150, getNodes())) {
      showNotification('Cannot place node here: overlapping with existing node', 'error');
      return;
    }

    try {
      const result = await createNodeInstance(nodeType, snappedX, snappedY, flowType);
      if (result) {
        const { nodeElement } = result;
        nodeElement.style.display = 'block';
        nodeElement.style.visibility = 'visible';
        nodeElement.style.opacity = '1';
        nodeElement.style.position = 'absolute';
        nodeElement.style.left = `${snappedX}px`;
        nodeElement.style.top = `${snappedY}px`;
        canvasContent.appendChild(nodeElement);
        enterTransition(nodeElement, 'scale', 300);
        setTimeout(() => {
          highlightElement(nodeElement, 'var(--primary)', 800);
        }, 300);
        addNode(nodeElement);
        initDraggableNodes([nodeElement], getNodes());

        setTimeout(() => {
          const rect = nodeElement.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const moveDelta = -30;
          const pointerDown = new PointerEvent('pointerdown', {
            bubbles: true,
            clientX: centerX,
            clientY: centerY,
            pointerId: 1,
            pointerType: 'mouse',
            isPrimary: true,
          });
          nodeElement.dispatchEvent(pointerDown);
          const pointerMove = new PointerEvent('pointermove', {
            bubbles: true,
            clientX: centerX + moveDelta,
            clientY: centerY,
            pointerId: 1,
            pointerType: 'mouse',
            isPrimary: true,
          });
          document.dispatchEvent(pointerMove);
          const pointerUp = new PointerEvent('pointerup', {
            bubbles: true,
            clientX: centerX + moveDelta,
            clientY: centerY,
            pointerId: 1,
            pointerType: 'mouse',
            isPrimary: true,
          });
          document.dispatchEvent(pointerUp);
        }, 0);
        console.log(`Successfully added ${nodeType} node at x=${snappedX}, y=${snappedY}`);
      }
    } catch (error) {
      console.error('Error creating node:', error);
      showNotification(`Failed to create ${nodeType} node`, 'error');
    }
  });
  initDraggableNodes(getNodes(), getNodes());
}
